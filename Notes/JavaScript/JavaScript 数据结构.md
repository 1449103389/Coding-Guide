<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [JavaScript 数据结构](#javascript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  - [链表](#%E9%93%BE%E8%A1%A8)
  - [集合](#%E9%9B%86%E5%90%88)
  - [字典（映射）](#%E5%AD%97%E5%85%B8%E6%98%A0%E5%B0%84)
  - [散列](#%E6%95%A3%E5%88%97)
    - [`分离链接`](#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5)
    - [`线性探索`](#%E7%BA%BF%E6%80%A7%E6%8E%A2%E7%B4%A2)
  - [二叉树](#%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [二叉搜索树（BST）](#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91bst)
    - [BST 的遍历](#bst-%E7%9A%84%E9%81%8D%E5%8E%86)
  - [图](#%E5%9B%BE)
    - [图的遍历](#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86)
    - [深度优先搜索 DFS & 广度优先搜索 BFS](#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs--%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## JavaScript 数据结构

### 链表

链表储存有序的元素集合，其中的元素在内存中不是连续放置的。对于**单向链表**，每个元素由一个储存**元素本身的节点**和一个**指向下一个元素的引用**组成；而**双向链表**中的各元素则多了一个**指向上一个元素的引用**

链表的存在有什么意义呢？

对于传统的数组而言，我们增加或删除一个元素时，需要移动其之后的元素。比如删除了 `index` 为 10 的元素，那么之前 `index` 为 11 的元素需要向前挪动一位；同理，后面的每一个元素都要向前挪动一位。

除此以外，链表和数组的又一个差别是，数组可以直接通过 `array[index]` 访问到 `index` 位上的元素；而对于链表而言，需要从头开始遍历到目标元素。

由此可知，当我们在**单向链表**中某个位置上插入一个元素 `node` 时：

1. 遍历查找到位于 `index` 的元素 `current`，以及它的上一位元素 `previous`
2. 将 `previous` 的 `next` 指向 `node`
3. 将 `node` 的 `next` 指向 `current`


同理，删除某个位置上的元素，即是将该位置的上一个元素的 `next` 指向了该位置的下一位元素。

对于双向链表而言，则多了设置 `pre` 指向上一个元素的一步。

### 集合

集合中的元素无序且唯一。可以按照插入元素的顺序来迭代集合中的各元素。

在 ES6 原生 API 中，支持了 [`Set` ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set) 和 [`WeakSet`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)。但要注意的一点是，尽管 `Set` 中的值是唯一的，且 JS 中 `NaN !== NaN` ，但在 `Set` 里 `NaN` 仍被认为是相同的值。除此以外，集合中以 `value, value` 的形式储存数据，即保存的 `value` 也会作为它本身的 `key` 便于索引查找。

### 字典（映射）

与 `Set` 中 `value` 做 `key` 不同，字典 `Map` 需要给 `value` 制定一个 `key` 。它也用来储存不重复的数据。

在 ES6 原生 API 中，有 [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map) 以及 [`WeakMap`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) 两种字典。

`WeakMap` 和 `WeakSet` 相比较于 `Map` 和 `Set` 而言：

- `WeakMap` 和 `WeakSet` 对象中只能存放*对象值*, 不能存放原始值, 而 `Map` 和 `Set` 都可以
- `WeakMap` 和 `WeakSet` 对象中存储的对象值都是被**弱引用**的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。
- 因此，`WeakMap` 和 `WeakSet` 对象是无法被枚举的, 没有办法拿到它包含的所有元素

### 散列

`HashTable`（或 `HashMap` ）。对散列中的元素而言，拥有一个特殊的键值（通常通过元素的 ASCII 码获取到），以此来增加索引的速度。除此以外，在删除某个元素以后，散列对该键的索引值将指向 `undefined` ，也就因此避免了改变其他元素的位置。

但其实有时候，不同元素计算得到的 `key` 依旧会有重复。如果是不加处理的普通散列，则当 `key` 重复时，后加入的元素会覆盖原有的元素。但我们可以通过`分离链接` 或者 `线性探索` 的方法解决这个问题。

#### `分离链接`

散列中的每一个 `key` 都指向一个链表；对于每个新增的元素，都会 push 到相对应的引用中去。这也就避免了元素 key 重复的问题，但很显然：占用了多余的储存空间。

#### `线性探索`

当想向表中某位置加入一个新元素时，如果索引为 `index` 的位置已经被其他元素占据了，则尝试 `index + 1` 的位置。如果仍然被占据，则继续尝试 `index + 2` 的位置；以此类推。

### 二叉树

如其名，是一个树状的数据结构，由很多节点组成，各节点可以有祖先节点（父节点等）和后代节点（子节点等）。节点的深度取决于它祖先节点的数量；树的深度则取决于所有节点深度的最大值。

#### 二叉搜索树（BST）

二叉树的一种。只允许在节点的左侧储存比父节点小的值，在右侧储存比父节点大的值。由此可知：

- 遍历 BST，每个节点只取其*左侧的子节点*进行递归，直至没有子节点。最终所得的数是树中的*最小值*。
- 遍历 BST，每个节点只取其*右侧的子节点*进行递归，直至没有子节点。最终所得的数是树中的*最大值*。

#### BST 的遍历

- 中序遍历

按照从最小到最大的顺序访问二叉树中的各节点。

- 先序遍历

先访问父节点，再访问其所有子节点。

- 后序遍历

先访问所有子节点，再访问父节点。

### 图

图是一种由边连接的节点（或顶点）。

- 相邻顶点：由一条边连接在一起的两个顶点
- 顶点的度：该顶点相邻顶点的数量
- 简单路径：不包含重复顶点的路径
- 环：简单路径的一种，表示从某顶点起始，不经过重复顶点，仍能回到初始顶点
- 无环：图中不存在环
- 连通：图中**每两个顶点间**都存在路径
- 强连通：图中每两个顶点间在双向上都存在路径

图可以通过**邻接表**这样的数据结构来表示。在邻接表中，用列表、链表或者散列来储存所有的顶点，并可以使用字典来储存`顶点: [顶点所有的邻接顶点]`

#### 图的遍历

图的遍历思想是，追踪每一个第一次访问的节点，并且追踪有哪些节点还没被完全探索过（该顶点的每条边都被查看过则算完全探索）。

1. 一开始，所有顶点被储存至**待访问顶点列表**中，并被标记为**未查看**。
2. 每经过一个顶点，将其标记为**已查看，未完全探索**。
3. 待与该顶点相连的所有变都经过以后，将该顶点标记为**已完全探索**。
4. **每个顶点至多访问两次**

#### 深度优先搜索 DFS & 广度优先搜索 BFS

两者基本相同，但待访问顶点列表的数据结构不同。

- DFS：堆栈的形式储存待访问顶点，元素后入先出。

从指定的第一个顶点开始遍历图，沿着某路径直到最后一个顶点；然后原路退回后搜索下一个路径。即先深入访问，再增加广度。

- BFS：队列的形式储存待访问顶点，元素先入先出。

从指定的第一个顶点开始遍历图，先访问所有的相邻点，即访问图的一层，然后深入到下一层进行递归。