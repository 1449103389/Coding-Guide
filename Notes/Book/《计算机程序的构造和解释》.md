<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [《计算机程序的构造和解释》读书记录](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95)
  - [构造过程抽象](#%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1)
  - [附：Scheme](#%E9%99%84scheme)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 《计算机程序的构造和解释》读书记录

> 计算机革命是有关我们如何去思考的方式，以及我们如何去表达自己的思考的一个革命

## 构造过程抽象

心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：

1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。
2. 将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。
3. 将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。

一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。每一种强有力的语言都为此提供了三种机制：

1. 基本表达式：用于表示语言所关心的最简单的个体
2. 组合的方法：通过它们可以从较简单的东西出发构造出复合的元素
3. 抽象的方法：通过它们可以为复合对象命名，并将它们当做单元去操作

在程序设计中，我们需要处理两类要素：**过程和数据**。任何强有力的程序设计语言都必须能够表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。

解释器对语句求值的过程，分为*应用序*和*正则序*两种。对于正则序求值，解释器会将语句完全展开然后规约。而对于应用序，则先求值参数而后应用。

人们对功能强大的程序设计语言有一个必然要求，就是能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。而过程提供了这种能力，因此，除了最简单的程序语言以外，其他语言都包含定义过程的机制。

但是即便在数值计算的过程中，如果将过程限制为只能以数作为参数，也会严重限制我们建立抽象的能力。经常有一些同样的程序设计模式能用于若干不同的过程。为了把这种模式描述为相应的概念，则需要构建出这样的过程：以过程为参数，或者以过程为返回值。*这类能操作过程的过程称为高阶过程*。

一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有最少限制的元素被称为具有第一级的状态。第一级元素的某些特权包括：

- 可以用变量命名
- 可以提供给过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

## 附：Scheme

```scheme
; 组合：括号 + 表达式
(+ 1 3) ; 4
(* 2 3 4) ; 24
(- (* 2 3) (+ 4 5)) ; -3

; 命名
(define size 2)
(define pi 3.14159)
(define radius 10)
(* pi radius radius) 314.159

; 复合过程
(define (square x) (* x x))
; (define (<name> <parameters>) <body>)
(square 21) ; 441
(square (+ 2 5)) ; 49
(+ (square 3) (square 2)) ; 13
; 利用复合过程定义复合过程
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 2 3) ; 13

; 条件表达式和谓词
; 类似其他语言的 switch 或者 case
; 一般形式为
#|
(cond (<p1> <e1>)
      ...
      (<pn> <en>))
|#
#|
首先包含了一个符号 cond，在它之后跟着一些称为子句的用括号括起来的表达式对偶 (<p> <e>)
在每个对偶中的第一个表达式是一个谓词（即 p），也就是说，这是一个表达式，它的值将被解释为真或者假
当某一个谓词为真时，返回后面的值，不再继续检查剩下的谓词
|#

(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))

(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))

; if 表达式
; (if <predicate><consequent><alternative>)
; 如果 predicate 为真，则求 consequent 的值并返回；否则求 alternative 的值并返回
(define (abs x)
  (if (< x 0)
      (- x)
      x))

; and/or/not 表达式
; (and <e1> ... <en>) 全部表达式为真时返回真，否则返回假
; (or <e1> ... <en>) 全部表达式为假时返回假，否则返回真
; (not <e>)

; lambda 表达式
; (lambda (<parameters>) <body>)
(lambda (x) (+ 4 x))

; let 创建局部变量
#|
(let ((<var1> <exp1>)
      (<var2> <exp2>)
      ...
      (<varn> <expn>))
    <body>)
|#
; 创建的变量只在 body 块内有效
; 38
(+ (let ((x 3))
        (+ x (* x 10)))
    5)
```
