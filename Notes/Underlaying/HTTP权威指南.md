<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [HTTP 权威指南](#http-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97)
  - [概述](#%E6%A6%82%E8%BF%B0)
    - [网络连接](#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)
    - [Web 的结构组件](#web-%E7%9A%84%E7%BB%93%E6%9E%84%E7%BB%84%E4%BB%B6)
  - [URL 与资源](#url-%E4%B8%8E%E8%B5%84%E6%BA%90)
  - [HTTP 报文](#http-%E6%8A%A5%E6%96%87)
  - [网络连接](#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5-1)
    - [TCP](#tcp)
    - [TCP 的连接](#tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5)
      - [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
      - [Nagle 算法](#nagle-%E7%AE%97%E6%B3%95)
      - [`TIME_WAIT`累积和端口耗尽](#time_wait%E7%B4%AF%E7%A7%AF%E5%92%8C%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD)
      - [TCP 连接关闭](#tcp-%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## HTTP 权威指南

### 概述

- URI：统一资源标识符
- URL：统一资源定位符。是 URI 的常见表现形式
- URN：统一资源名，与位置无关的资源。是 URI 的另一种形式

- 幂等性：同一个事务，不管执行多少次，得到的结果都相同

#### 网络连接

HTTP 请求是应用层协议，它把联网的细节都交给了网络传输协议 TCP/IP。从底层到上层的协议栈如下：

1. 物理网络硬件（物理层）
2. 网络特有的链路接口（数据链路层）
3. IP（网络层）
4. TCP/UDP（传输层）
5. HTTP（应用层）

#### Web 的结构组件

- 代理

代理位于客户端和服务器之间，用于接收 HTTP 请求，（可能对请求进行修改）然后进行转发

- 网关

也是一个中间实体，通常用于将 HTTP 流量转换为其他的协议

- 隧道

通过隧道，可以在两条连接之间对原始数据进行盲转发。常见应用是 HTTPS

- User-Agent

用户代理代表用户发起 HTTP 请求的客户端程序

### URL 与资源

URL 的通用表示：

`<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`

- `scheme`：方案，访问资源的形式。常见的有`http`, `https`, `mailto`, `ftp` 等
- `host`：主机，资源宿主服务器的主机名或者 IP 地址
- `path`：路径，服务器上路径的本地名
- `frag`：片段。URL 支持使用片段组件来表示一个资源内部的片段。但服务器通常只处理整个对象，因此需要由客户端来决定根据片段展现的资源

### HTTP 报文

HTTP 报文的三个部分：起始行、首部、主体；分成两大类：请求报文和相应报文。

请求报文的格式：

```bash
<method> <request-URL> <version>
<headers>
<entity-body>
```

相应报文的格式：

```bash
<version> <status> <reason-phrase>
<headers>
<entity-body>
```

- version: 请求所使用的 HTTP 版本。格式为`HTTP/<major>.<minor>`
- reason-phrase: 原因短语
- entity-body: 主体部分
- status: 状态码

状态码分类：

1. 100~199：信息提示
2. 200~299：成功
3. 300~399：重定向
4. 400~499：客户端错误
5. 500~599：服务器错误

常见状态码说明：

- `100 - Continue`服务器已收到请求的初始部分，客户端可以继续。一般用于客户端避免向服务器发送一个无法处理或大实体时，首先进行确认
- `201 - Created`相应用于创建服务器对象的请求
- `202 - Accepted`请求已被接受，但不保证已经完成
- `301 - Moved Permanently`代表资源已经被永久移除
- `302 - Found`/`307 - Temporary Redirect`代表临时重定向
- `400 - Bad Request`客户端发送了错误的请求
- `401 - Unauthorized`客户端需要权限认证
- `403 - Forbidden`客户端的请求被服务端拒绝
- `405 - Method Not Allowed`客户端发起请求的方法不被服务器支持
- `408 - Request Timeout`客户端完成请求所花的时间太长，导致请求超时
- `500 - Internal Server Error`服务器错误
- `502 - Bad  Gateway`网关错误
- `503 - Service Unavailable`服务器目前无法提供服务
- `504 - Gateway Timeout`网关超时

### 网络连接

#### TCP

在 HTTP 请求的时候，首先要建立 TCP 连接，来为 HTTP 提供可靠的比特传输通道。TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。而 HTTPS 就是在 HTTP 和 TCP 之间插入了密码加密层。

每一个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址。每个 IP 分组中包括：

- 一个 IP 分组首部
- 一个 TCP 段首部：包含源 IP、目的 IP、长度等
- 一个 TCP 数据块：包含 TCP 端口号、TCP 控制标记

TCP 连接是通过如下 4 个值来进行识别的：

`<源 IP 地址、源端口号、目的 IP 地址、目的端口号>`

4 个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件。

#### TCP 的连接

##### 三次握手

在创建连接时，需要经过下面三次握手：

1. 客户端向服务器发送一个小的 TCP 分组，在分组中设置了特殊的 SYN 标记，说明是一个连接的请求
2. 如果服务器接受了连接，则向客户端回送一个 TCP 分组，该分组内 SYN 和 ACK 标记都被置位，说明请求已经被接受
3. 最后，客户端向服务器回送一条确认消息

每个 TCP 段都有一个序列号和数据完整性校验。每个段的接收者在收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，则发送者会认为分组已被损坏，并重新发送数据。

##### Nagle 算法

TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中。但如果 TCP 发送了大量包含少量数据的分组，则会严重影响网络性能。而 Nagle 算法会试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。

Nagle 算法原理：

1. 鼓励发送全尺寸的段。只有当其他所有分组都被确认之后，才允许发送非全尺寸的段
2. 如果其他分组仍在传输过程中，则会将数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送的全尺寸数据时，才会发出缓存的数据

Nagle 算法缺陷：

1. 小的 HTTP 报文可能无法填满一个分组，因此需要等待其他数据，产生延迟
2. 缓存阻碍数据的发送，知道有确认分组抵达为止

##### `TIME_WAIT`累积和端口耗尽

`TIME_WAIT`累积：

当某个 TCP 端口关闭连接时，会在内存中维护一个小的控制块，用于记录最近所关闭的 IP 地址和端口号。这类信息大概会维持 2 分钟（俗称 2MSL，为最大分段使用期的 2 倍），以确保在这段时间内不会创建相同地址和端口的新连接。

当并发数很高时，或者短时间内请求数很大，由于源端口数有限，且`TIME_WAIT`累积，则可能造成端口的耗尽问题。

##### TCP 连接关闭

- 半关闭：关闭 TCP 输入、输出通道中的一个
- 完全关闭：TCP 输入、输出通道都关闭

关闭连接的输出通道总是很安全。这样连接的另一端在读取了所有已输出的数据后，会收到一条流结束的通知，从而得知连接关闭。
而关闭连接的输入通道则比较危险。如果连接的另一端向已经关闭的输入通道发送数据，则接受到数据的操作系统会向发送方发出一条“TCP 连接被对端重置”的报文，造成发送方删除其还未读取的所有缓存数据。

正常关闭的应用程序应首先关闭其自身的输出信道，然后等待连接的另一端关闭它的输出信道，两者相互之间不再发送数据，就不会有重置的危险。